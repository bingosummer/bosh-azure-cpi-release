# frozen_string_literal: true

module Bosh::AzureCloud
  class VMManager
    private

    def _get_availability_set_name(vm_props, env)
      availability_set_name = vm_props.availability_set
      if availability_set_name.nil?
        unless env.nil? || env['bosh'].nil? || env['bosh']['group'].nil?
          availability_set_name = env['bosh']['group']

          # https://github.com/cloudfoundry-incubator/bosh-azure-cpi-release/issues/209
          # On Azure the length of the availability set name must be between 1 and 80 characters.
          # The group name which is generated by BOSH director may be too long.
          # CPI will truncate the name to below format if the length is greater than 80.
          # az-MD5-[LAST-40-CHARACTERS-OF-GROUP]
          if availability_set_name.length > 80
            availability_set_name = "az-#{Digest::MD5.hexdigest(availability_set_name)}-#{availability_set_name[-40..-1]}"
          end
        end
      end

      return nil if availability_set_name.nil? # When creating BOSH director

      availability_set_1_name = availability_set_name
      availability_set_2_name = "#{availability_set_name}x"
      resource_group_name = vm_props.resource_group_name
      availability_set_1 = @azure_client.get_availability_set_by_name(resource_group_name, availability_set_1_name)
      availability_set_2 = @azure_client.get_availability_set_by_name(resource_group_name, availability_set_2_name)
      if availability_set_1.nil?
        if availability_set_2.nil?
          return availability_set_1_name
        else
          return _is_vm_size_available_in_availability_set(availability_set_2_name, vm_props) ? availability_set_2_name : availability_set_1_name
        end
      else
        return _is_vm_size_available_in_availability_set(availability_set_1_name, vm_props) ? availability_set_1_name : availability_set_2_name
      end
    end

    def _is_vm_size_available_in_availability_set(availability_set_name, vm_props)
      @logger.info("binxitest: #{availability_set_name}, #{vm_props.inspect}")
      resource_group_name = vm_props.resource_group_name
      vm_size = vm_props.instance_type
      available_vm_sizes = @azure_client.list_available_virtual_machine_sizes_by_availability_set(resource_group_name, availability_set_name)
      @logger.info("binxitest: include? #{available_vm_sizes.include?(vm_size)}")
      available_vm_sizes.each do |available_vm_size|
        return true if available_vm_size[:name] == vm_size
      end

      load_balancer_name = vm_props.load_balancer
      unless load_balancer_name.nil?
        load_balancer = @azure_client.get_load_balancer_by_name(load_balancer_name)
        if load_balancer['sku_name'] == LOAD_BALANCER_SKU_BASIC
          cloud_error("Instance type '#{vm_size}' doesn't exist in availability set '#{availability_set_name}'. Failed to move VMs to a new availability set because a Basic SKU load balancer '#{load_balancer_name}' is associated with the VMs. Please migrate to Standard SKU load balancer and try again.")
        end
      end

      false
    end

    def _get_or_create_availability_set(resource_group_name, availability_set_name, vm_props, location)
      return nil if availability_set_name.nil?

      availability_set_params = {
        name: availability_set_name,
        location: location,
        tags: AZURE_TAGS,
        platform_update_domain_count: vm_props.platform_update_domain_count,
        platform_fault_domain_count: vm_props.platform_fault_domain_count,
        managed: @use_managed_disks
      }
      availability_set = nil
      flock("#{CPI_LOCK_PREFIX_AVAILABILITY_SET}-#{availability_set_name}", File::LOCK_EX) do
        availability_set = @azure_client.get_availability_set_by_name(resource_group_name, availability_set_name)
        if availability_set.nil?
          @logger.info("availability set '#{availability_set_name}' doesn't exist. Will create a new one.")
          @azure_client.create_availability_set(resource_group_name, availability_set_params)
          availability_set = @azure_client.get_availability_set_by_name(resource_group_name, availability_set_name)
        # In some regions, location of availability set is case-sensitive, e.g. CanadaCentral instead of canadacentral.
        elsif !availability_set[:location].casecmp(availability_set_params[:location]).zero?
          cloud_error("availability set '#{availability_set_name}' already exists, but in a different location '#{availability_set[:location].downcase}' instead of '#{availability_set_params[:location].downcase}'. Please delete availability set or choose another location.")
        elsif !@use_managed_disks && availability_set[:managed]
          cloud_error("availability set '#{availability_set_name}' already exists. It's not allowed to update it from managed to unmanaged.")
        elsif @use_managed_disks && !availability_set[:managed]
          @logger.info("availability set '#{availability_set_name}' exists, but it needs to be updated from unmanaged to managed.")
          availability_set_params.merge!(
            platform_update_domain_count: availability_set[:platform_update_domain_count],
            platform_fault_domain_count: availability_set[:platform_fault_domain_count],
            managed: true
          )
          @azure_client.create_availability_set(resource_group_name, availability_set_params)
          availability_set = @azure_client.get_availability_set_by_name(resource_group_name, availability_set_name)
        else
          @logger.info("availability set '#{availability_set_name}' exists. No need to update.")
        end
      end
      cloud_error("availability set '#{availability_set_name}' is not created.") if availability_set.nil?
      availability_set
    end

    def _delete_empty_availability_set(resource_group_name, availability_set_name)
      flock("#{CPI_LOCK_PREFIX_AVAILABILITY_SET}-#{availability_set_name}", File::LOCK_EX | File::LOCK_NB) do
        availability_set = @azure_client.get_availability_set_by_name(resource_group_name, availability_set_name)
        @azure_client.delete_availability_set(resource_group_name, availability_set_name) if availability_set && availability_set[:virtual_machines].empty?
      end
    end
  end
end
